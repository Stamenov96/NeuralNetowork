package org.exampl.neuralnet;

public class NeuralNetworksProgram {
	public static void main(String[] args) { 
	{
	      try
	      {
	        Console.WriteLine("\nBegin Neural Network demo\n");

	        Console.WriteLine("Creating a 3-input, 4-hidden, 2-output neural network");
	        Console.WriteLine("Using sigmoid function for input-to-hidden activation");
	        Console.WriteLine("Using tanh function for hidden-to-output activation");
	        NeuralNetwork nn = new NeuralNetwork(3, 4, 2);

	        double[] weights = new double[] {
	          0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2,
	          -2.0, -6.0, -1.0, -7.0,
	          1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0,
	          -2.5, -5.0 };

	        Console.WriteLine("\nWeights and biases are:");
	        Helpers.ShowVector(weights);

	        Console.WriteLine("Loading neural network weights and biases");
	        nn.SetWeights(weights);

	        Console.WriteLine("\nSetting inputs:");
	        double[] xValues = new double[] { 1.0, 2.0, 3.0 };
	        Helpers.ShowVector(xValues);
	        
	        Console.WriteLine("Loading inputs and computing outputs");
	        double[] yValues = nn.ComputeOutputs(xValues);

	        Console.WriteLine("\nNeural network outputs are:");
	        Helpers.ShowVector(yValues);

	        Console.WriteLine("End Neural Network demo\n");
	        Console.ReadLine();
	      }
	      catch (Exception ex)
	      {
	        Console.WriteLine("Fatal: " + ex.Message);
	        Console.ReadLine();
	      }
	    } // Main

	  } // class NeuralNetworksProgram

	  class NeuralNetwork
	  {
	    private int numInput;
	    private int numHidden;
	    private int numOutput;

	    private double[] inputs;
	    private double[][] ihWeights; // input-to-hidden
	    private double[] ihSums;
	    private double[] ihBiases;
	    private double[] ihOutputs;
	    private double[][] hoWeights;  // hidden-to-output
	    private double[] hoSums;
	    private double[] hoBiases;
	    private double[] outputs;

	    public NeuralNetwork(int numInput, int numHidden, int numOutput)
	    {
	      this.numInput = numInput;
	      this.numHidden = numHidden;
	      this.numOutput = numOutput;

	      inputs = new double[numInput];
	      ihWeights = Helpers.MakeMatrix(numInput, numHidden);
	      ihSums = new double[numHidden];
	      ihBiases = new double[numHidden];
	      ihOutputs = new double[numHidden];
	      hoWeights = Helpers.MakeMatrix(numHidden, numOutput);
	      hoSums = new double[numOutput];
	      hoBiases = new double[numOutput];
	      outputs = new double[numOutput];
	    }

	    public void SetWeights(double[] weights)
	    {
	      int numWeights = (numInput * numHidden) + (numHidden * numOutput) + numHidden + numOutput;
	      if (weights.Length != numWeights)
	        throw new Exception("The weights array length: " + weights.Length + " does not match the total number of weights and biases: " + numWeights);

	      int k = 0; // points into weights param

	      for (int i = 0; i < numInput; ++i)
	        for (int j = 0; j < numHidden; ++j)
	          ihWeights[i][j] = weights[k++];

	      for (int i = 0; i < numHidden; ++i)
	        ihBiases[i] = weights[k++];

	      for (int i = 0; i < numHidden; ++i)
	        for (int j = 0; j < numOutput; ++j)
	          hoWeights[i][j] = weights[k++];

	      for (int i = 0; i < numOutput; ++i)
	        hoBiases[i] = weights[k++];
	    }

	    public double[] ComputeOutputs(double[] xValues)
	    {
	      if (xValues.Length != numInput)
	        throw new Exception("Inputs array length " + inputs.Length + " does not match NN numInput value " + numInput);

	      for (int i = 0; i < numHidden; ++i)
	        ihSums[i] = 0.0;
	      for (int i = 0; i < numOutput; ++i)
	        hoSums[i] = 0.0;
	 
	      for (int i = 0; i < xValues.Length; ++i) // copy x-values to inputs
	        this.inputs[i] = xValues[i];

	      //Console.WriteLine("Inputs:");
	      //Helpers.ShowVector(this.inputs);

	      //Console.WriteLine("input-to-hidden weights:");
	      //Helpers.ShowMatrix(this.ihWeights, -1);

	      for (int j = 0; j < numHidden; ++j)  // compute input-to-hidden weighted sums
	        for (int i = 0; i < numInput; ++i)
	          ihSums[j] += this.inputs[i] * ihWeights[i][j];

	      //Console.WriteLine("input-to-hidden sums:");
	      //Helpers.ShowVector(this.ihSums);

	      //Console.WriteLine("input-to-hidden biases:");
	      //Helpers.ShowVector(ihBiases);

	      for (int i = 0; i < numHidden; ++i)  // add biases to input-to-hidden sums
	        ihSums[i] += ihBiases[i];

	      Console.WriteLine("\ninput-to-hidden sums after adding i-h biases:");
	      Helpers.ShowVector(this.ihSums);

	      for (int i = 0; i < numHidden; ++i)   // determine input-to-hidden output
	        //ihOutputs[i] = StepFunction(ihSums[i]); // step function
	        ihOutputs[i] = SigmoidFunction(ihSums[i]);

	      //Console.WriteLine("\ninput-to-hidden outputs after sigmoid:");
	      //Helpers.ShowVector(this.ihOutputs);

	      //Console.WriteLine("hidden-to-output weights:");
	      //Helpers.ShowMatrix(hoWeights, -1);

	      for (int j = 0; j < numOutput; ++j)   // compute hidden-to-output weighted sums
	        for (int i = 0; i < numHidden; ++i)
	          hoSums[j] += ihOutputs[i] * hoWeights[i][j];

	      //Console.WriteLine("hidden-to-output sums:");
	      //Helpers.ShowVector(hoSums);

	      //Console.WriteLine("hidden-to-output biases:");
	      //Helpers.ShowVector(this.hoBiases);

	      for (int i = 0; i < numOutput; ++i)  // add biases to input-to-hidden sums
	        hoSums[i] += hoBiases[i];

	      Console.WriteLine("hidden-to-output sums after adding h-o biases:");
	      Helpers.ShowVector(this.hoSums);

	      for (int i = 0; i < numOutput; ++i)   // determine hidden-to-output result
	        this.outputs[i] = HyperTanFunction(hoSums[i]);
	 
	      double[] result = new double[numOutput];
	      this.outputs.CopyTo(result, 0);
	      
	      return result;
	    } // ComputeOutputs

	    private static double StepFunction(double x)
	    {
	      if (x > 0.0) return 1.0;
	      else return 0.0;
	    }

	    private static double SigmoidFunction(double x)
	    {
	      if (x < -45.0) return 0.0;
	      else if (x > 45.0) return 1.0;
	      else return 1.0 / (1.0 + Math.Exp(-x));
	    }

	    private static double HyperTanFunction(double x)
	    {
	      if (x < -10.0) return -1.0;
	      else if (x > 10.0) return 1.0;
	      else return Math.Tanh(x);
	    }
	  } // class NeuralNetwork


	  public class Helpers
	  {
	    public static double[][] MakeMatrix(int rows, int cols)
	    {
	      double[][] result = new double[rows][];
	      for (int i = 0; i < rows; ++i)
	        result[i] = new double[cols];
	      return result;
	    }

	    public static void ShowVector(double[] vector)
	    {
	      for (int i = 0; i < vector.Length; ++i)
	      {
	        if (i > 0 && i % 12 == 0) // max of 12 values per row 
	          Console.WriteLine("");
	        if (vector[i] >= 0.0) Console.Write(" ");
	        Console.Write(vector[i].ToString("F2") + " "); // 2 decimals
	      }
	      Console.WriteLine("\n");
	    }

	    public static void ShowMatrix(double[][] matrix, int numRows)
	    {
	      int ct = 0;
	      if (numRows == -1) numRows = int.MaxValue; // if numRows == -1, show all rows
	      for (int i = 0; i < matrix.Length && ct < numRows; ++i)
	      {
	        for (int j = 0; j < matrix[0].Length; ++j)
	        {
	          if (matrix[i][j] >= 0.0) Console.Write(" "); // blank space instead of '+' sign
	          Console.Write(matrix[i][j].ToString("F2") + " ");
	        }
	        Console.WriteLine("");
	        ++ct;
	      }
	      Console.WriteLine("");
	    }
	  } // class Helpers
	  
	} // ns

}
